빈발 항목 쌍 지지도 계산(Pass 2)은 **A-Priori 알고리즘**이라는 빈발 항목 찾기(Frequent Itemsets)의 더 큰 맥락에서 중요한 단계입니다. A-Priori 알고리즘은 일반적으로 디스크 상에 저장된 데이터를 여러 번 읽는(Pass) 방식으로 빈발 항목 집합을 찾는 2단계 접근 방식이며, 메인 메모리 사용량을 제한하는 것을 목표로 합니다.

A-Priori 알고리즘에서 Pass 2가 갖는 역할과 의의는 다음과 같습니다.

### 1. 빈발 항목 찾기의 핵심 난제 (L2)
빈발 항목을 찾는 문제에서, 가장 어려운 부분은 종종 **빈발 항목 쌍**($\{i_1, i_2\}$), 즉 크기 2인 빈발 항목 집합($L_2$)을 찾는 것입니다. 이는 빈발 쌍이 흔한 반면, 빈발 삼중 항목(triples)은 상대적으로 드물기 때문입니다. 만약 나이브한 접근 방식을 사용하여 모든 가능한 항목 쌍을 메인 메모리에서 세려고 하면, 항목의 수가 $10^5$개에 달할 경우 필요한 메모리 크기가 수십 기가바이트(약 20GB)에 이르러 실패할 수 있습니다.

### 2. A-Priori의 핵심 원리: 단조성 (Monotonicity)
A-Priori 알고리즘은 **단조성**이라는 핵심 아이디어를 활용하여 이 문제를 해결합니다. 단조성은 "만약 항목 집합 $I$가 최소 $s$번 나타난다면, $I$의 모든 부분 집합 $J$도 최소 $s$번 나타나야 한다"는 원리입니다.

이 원리의 대우(contrapositive)를 항목 쌍에 적용하면, "만약 항목 $i$가 $s$개의 장바구니에 나타나지 않는다면, $i$를 포함하는 어떤 항목 쌍도 $s$개의 장바구니에 나타날 수 없다"는 결론이 나옵니다.

### 3. Pass 2: 빈발 쌍 지지도 계산의 구체적인 단계
A-Priori 알고리즘은 이 단조성을 활용하여 두 단계로 빈발 쌍($L_2$)을 계산합니다:

*   **Pass 1 (L1 계산):** 첫 번째 단계에서 모든 장바구니를 읽고 각 **개별 항목**의 발생 횟수를 메인 메모리에서 계산합니다. 이 단계는 항목의 수에 비례하는 메모리만 필요합니다. 이를 통해 빈발 항목들의 집합 $L_1$을 찾습니다.
*   **Pass 2 (L2 계산):** 두 번째 단계에서 장바구니를 **다시 읽습니다**. 이 때, Pass 1에서 **빈발 항목으로 확인된 두 항목으로 구성된 쌍**만 메인 메모리에서 계산합니다.

결과적으로, Pass 2는 메인 메모리에서 **빈발 항목의 제곱에 비례하는** 메모리만 필요하도록 하여(후보 쌍의 카운트를 위해) 효율성을 크게 높입니다. 이 과정을 통해 A-Priori는 **진정한 빈발 k-튜플 집합**($L_2$)을 찾게 됩니다.

A-Priori 알고리즘은 일반적으로 항목 집합의 크기 $k$마다 한 번의 통과(Pass)를 수행하며, 대부분의 장바구니 데이터와 합리적인 지지도($s$) 임계값(예: 1%)의 경우, **$k=2$인 Pass 2가 가장 많은 메모리를 필요로 합니다**. Pass 2를 효율적으로 수행하기 위해 빈발 항목들을 1, 2, ... 와 같이 새로운 번호로 다시 매기고 삼각 행렬 방법을 사용하여 공간을 절약할 수도 있습니다.