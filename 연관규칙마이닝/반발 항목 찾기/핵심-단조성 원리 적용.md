A-Priori 알고리즘은 **단조성(Monotonicity)** 원리를 핵심 아이디어로 사용하여, 연관 규칙 마이닝에서 가장 어렵고 메모리 집약적인 단계인 **빈발 품목 집합(Frequent Itemsets) 찾기**를 효율적으로 수행합니다.

### 1. 단조성 원리의 정의

A-Priori 알고리즘의 핵심은 다음 원리에 있습니다.

*   **단조성 원리:** "**만약 항목 집합 $I$가 최소 $s$회(지지도 임계값) 나타난다면, $I$의 모든 부분 집합 $J$도 최소 $s$회 나타나야 한다**"는 것입니다.
*   **대우(Contrapositive) 적용:** 이 원리의 대우는 빈발 품목 집합을 찾는 데 사용됩니다. 특히 항목 쌍을 찾는 경우, "**만약 항목 $i$가 $s$개의 장바구니에 나타나지 않는다면, $i$를 포함하는 어떤 쌍도 $s$개의 장바구니에 나타날 수 없다**"는 결론을 도출할 수 있습니다.

### 2. 빈발 항목 찾기(A-Priori)에서의 단조성 적용

단조성 원리는 빈발 항목 집합을 체계적으로 찾고, 불필요한 계산을 줄이기 위한 **가지치기(Pruning)** 과정의 기반이 됩니다.

#### 메모리 제한 해결 및 가지치기

A-Priori는 메인 메모리 요구 사항을 제한하기 위해 2-Pass 접근 방식을 사용하며, 단조성 원리는 후보 품목 집합의 수를 줄이는 데 결정적인 역할을 합니다.

1.  **1단계 (Pass 1 - $L_1$ 찾기):** 장바구니 데이터를 한 번 읽으면서 개별 항목의 발생 횟수를 세어 빈발 항목($L_1$)을 식별합니다.
2.  **2단계 (Pass 2 - $L_2$ 후보 생성 및 가지치기):**
    *   단조성 원리의 대우에 따라, 빈발하지 않은 항목을 포함하는 쌍은 빈발할 수 없으므로, **Pass 1에서 빈발로 확인된 항목들만으로 구성된 쌍**($C_2$)만을 카운트합니다.
    *   이를 통해 모든 가능한 쌍의 수를 세는 대신, **빈발 항목 수의 제곱에 비례**하는 메모리만 사용하여 카운트를 수행하게 되어 메모리 사용량을 크게 절약합니다.

#### 일반적인 $k$ 크기 항목 집합으로의 확장

A-Priori는 이 원리를 모든 크기($k$)의 빈발 항목 집합을 찾는 데 일반화하여 적용합니다.

*   **후보 생성 ($C_k$):** $k$ 크기의 빈발 항목 집합($L_k$)을 찾기 위해서는, 먼저 $k-1$ 크기의 빈발 집합($L_{k-1}$) 정보를 기반으로 **후보 $k$-튜플($C_k$)**을 생성합니다.
*   **필터링 (Pruning):** 이 과정에서 $L_{k-1}$의 모든 항목을 포함하지 않는 후보는 단조성 원리에 의해 빈발할 수 없으므로 생성 단계에서부터 필터링됩니다. 이후, 데이터에 대한 패스를 통해 $C_k$의 지지도를 계산하여 최종적인 빈발 집합 $L_k$를 얻습니다.

즉, A-Priori는 단조성 원리를 활용하여 **빈발하지 않은 항목 집합을 포함하는 더 큰 항목 집합 후보를 제거**함으로써($L_k$는 $C_k$의 가지치기된 결과), 계산량을 크게 줄이고 효율성을 확보합니다.