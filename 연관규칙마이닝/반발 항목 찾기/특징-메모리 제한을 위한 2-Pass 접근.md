**A-Priori 알고리즘**의 **2-Pass 접근 방식**은 연관 규칙 마이닝에서 가장 까다로운 문제인 **빈발 품목 집합($L_k$) 찾기**를 수행할 때 발생하는 **메인 메모리 제약**을 해결하기 위한 핵심 특징입니다.

### 1. 문제의 배경: 메모리 병목 현상

빈발 항목 집합을 찾는 많은 알고리즘에서 **메인 메모리**는 결정적인 자원입니다. 특히 빈발 쌍($k=2$)의 발생 횟수를 셀 때, 항목의 수가 많을 경우($10^5$개의 항목이 있는 경우 $5 \times 10^9$개의 쌍이 가능하며, 약 20GB의 메모리가 필요함), 메인 메모리 용량을 초과하여 카운트 값을 스와핑(swapping)해야 하면 치명적인 결과를 초래할 수 있습니다.

### 2. 2-Pass 접근 방식의 작동 원리

A-Priori는 항목 쌍을 카운트하기 전에 데이터에 대한 **두 번의 패스(Two-pass)**를 통해 **단조성(Monotonicity)** 원리를 적용하여 메모리 사용을 제한합니다. 단조성 원리란, 어떤 항목 집합 $I$가 빈발하면($s$회 이상 나타나면), $I$의 모든 부분 집합도 빈발해야 한다는 것입니다.

#### Pass 1: 빈발 개별 항목($L_1$) 식별

*   **목표:** 개별 항목들의 발생 횟수(지지도)를 계산합니다.
*   **실행:** 전체 장바구니 데이터를 **한 번 읽으면서(Pass 1)**, 각 개별 항목의 발생 횟수를 메인 메모리에서 셉니다.
*   **메모리 효율성:** 이 단계는 항목의 총 개수에 비례하는 메모리만 필요로 합니다.
*   **결과:** 지지도 임계값 $s$ 이상으로 나타나는 항목들을 **빈발 항목($L_1$)**으로 식별합니다.

#### Pass 2: 빈발 쌍($L_2$) 카운트 및 메모리 제한

*   **목표:** 빈발 항목 쌍($L_2$)을 찾습니다.
*   **단조성 적용 및 가지치기:** Pass 1의 결과($L_1$)를 사용하여, **빈발하지 않은 항목($i$)을 포함하는 어떤 쌍도 빈발할 수 없다**는 단조성 원리의 대우를 적용합니다.
*   **실행:** 데이터를 **다시 한 번 읽으면서(Pass 2)**, **Pass 1에서 빈발로 확인된 항목들($L_1$)로만 구성된 쌍**의 발생 횟수($C_2$, 후보 쌍)만 메인 메모리에서 셉니다.
*   **메모리 절약 효과:** 이 선별적인 카운팅 덕분에 필요한 메모리는 전체 항목 수의 제곱이 아닌, **빈발 항목 수의 제곱에 비례**하는 메모리만 필요하게 되어, 대규모 데이터셋에서 메인 메모리 제약을 효과적으로 회피할 수 있게 됩니다. 또한, 빈발 항목 목록 자체를 저장할 메모리 공간도 필요합니다.

결과적으로, A-Priori는 2-Pass 접근 방식을 통해 데이터에 대한 패스를 반복하면서도, 각 단계에서 단조성 원리를 적용하여 실제로 빈발할 가능성이 없는 후보($C_k$)를 제거(Prune)함으로써, **계산량과 메모리 요구 사항을 크게 줄입니다**. 일반적으로, 이 2-Pass를 통해 **$k=2$인 빈발 쌍을 찾는 과정이 가장 많은 메모리를 요구**합니다.