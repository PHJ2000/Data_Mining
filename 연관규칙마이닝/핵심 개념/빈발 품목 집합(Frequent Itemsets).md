빈발 품목 집합(Frequent Itemsets)은 연관 규칙 마이닝(Association Rule Mining)의 **가장 기본적인 핵심 개념**이며, 항목 간의 의존성 및 연관 규칙을 발견하기 위한 출발점이 됩니다.

### 1. 빈발 품목 집합의 정의 및 측정

빈발 품목 집합은 장바구니 모델(Market-Basket Model) 내에서 "자주" 함께 나타나는 항목들의 집합을 찾는 가장 간단한 질문에 대한 답입니다.

*   **정의:** **지지도 임계값 $s$ 이상**의 장바구니에 나타나는 항목 집합을 빈발 품목 집합이라고 부릅니다.
*   **지지도(Support):** 빈발도를 측정하는 지표입니다. 항목 집합 $I$의 지지도는 $I$에 포함된 **모든 항목을 담고 있는 장바구니의 수**를 의미합니다 (이는 전체 장바구니 수에 대한 비율로 표현되기도 합니다).

### 2. 연관 규칙 발견 과정에서의 역할

빈발 품목 집합을 찾는 것은 연관 규칙 마이닝 프로세스 전체를 통틀어 **가장 중요하고 어려운 단계(Hard part)**입니다.

*   **필수 조건:** 어떤 규칙이 높은 지지도(support)와 신뢰도(confidence)를 갖는다면, 해당 규칙의 왼쪽 항목 집합과 규칙 전체 항목 집합 **모두** "빈발(frequent)"해야 합니다.
*   **프로세스 단계 1:** 연관 규칙 마이닝은 두 단계로 이루어지는데, **1단계는 모든 빈발 품목 집합 $I$를 찾는 것**입니다.
*   **프로세스 단계 2 (규칙 생성):** 빈발 품목 집합 $I$가 확보되면, $I$의 모든 부분 집합 $A$에 대해 $A \rightarrow I \setminus A$ 형태의 규칙을 생성하고 신뢰도를 계산하여 임계값 이상의 규칙을 출력합니다. **$I$가 빈발하므로 $I$의 부분 집합 $A$ 역시 빈발해야 합니다**.

### 3. 계산상의 어려움 및 A-Priori 알고리즘

빈발 품목 집합을 찾는 문제는 대규모 데이터에서 계산 효율성과 메인 메모리 사용 측면에서 큰 도전입니다.

*   **메모리 병목 현상:** 많은 빈발 품목 집합 알고리즘에서 **메인 메모리**가 중요한 자원이며, 항목 쌍의 발생 횟수를 세기 위해 필요한 메모리가 제약을 가할 수 있습니다.
*   **빈발 쌍의 난이도:** 흥미롭게도, **빈발 쌍($k=2$)**을 찾는 것이 종종 **가장 어려운 문제**로 밝혀집니다. 이는 품목 집합 크기가 커질수록 빈발할 확률이 기하급수적으로 감소하는 반면, 항목 쌍의 수가 가장 많은 메모리를 요구하기 때문입니다.
*   **A-Priori의 핵심 원리:** 이 문제를 효율적으로 해결하기 위해 **A-Priori 알고리즘**이 사용됩니다. 이 알고리즘의 핵심 아이디어는 **단조성(monotonicity)**입니다.
    *   **단조성:** "품목 집합 $I$가 최소 $s$회 나타난다면, $I$의 모든 부분 집합 $J$도 최소 $s$회 나타나야 한다"는 원리입니다.
    *   **후보 필터링:** 이 원리를 이용해, $k-1$ 크기의 빈발 품목 집합($L_{k-1}$)에서만 $k$ 크기의 후보($C_k$)를 생성하고, 이후 빈발하지 않은 후보를 제거(Prune)함으로써 계산량을 줄입니다. A-Priori는 일반적으로 두 번의 데이터 패스(Pass)를 통해 빈발 항목을 식별하고 그 쌍의 수를 세는 방식으로 메인 메모리 요구 사항을 제한합니다.

### 4. 출력 압축

발견된 빈발 품목 집합의 수가 너무 많아질 경우, 출력을 압축하기 위해 다음과 같은 개념을 사용할 수 있습니다.

*   **최대 빈발 품목 집합(Maximal frequent itemsets):** 빈발한 상위 집합이 없는 빈발 집합입니다.
*   **닫힌 품목 집합(Closed itemsets):** 동일한 카운트(지지도)를 가지는 상위 집합이 없는 항목 집합입니다. 이는 빈발 정보뿐만 아니라 정확한 카운트 정보까지 저장합니다.